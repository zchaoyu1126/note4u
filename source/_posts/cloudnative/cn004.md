---
title: Docker 命令
abbrlink: f5f9fa9b
date: 2023-04-10 15:07:02
tags:
hide: true
categories: Cloud Native
cover: http://img.note4u.top/base/cnnotes_cover.jpg
---


## Docker 基础命令

命令行文档：https://docs.docker.com/engine/reference/commandline/docker/

**docker hub相关**
- docker search
- docker pull
- docker push

- docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
    - 示例：
        - docker run busybox echo "Hello World" 
        - docker run -it centos
        - docker run -it centos /bin/bash
    - IMAGE: \<image\>:\<tag\>，没有tag则默认为latest
    - -i: 以交互模式运行容器
    - -t: 为容器重新分配一个伪输入终端
    - -d: 后台运行容器，并返回容器ID

    {% note info simple %}
    Docker中系统镜像的缺省命令是 bash，如果不加 -ti bash 命令执行了自动会退出。这是因为如果没有衔接输入流，本身就会马上结束。加-ti 后docker命令会为容器分配一个伪终端，并接管其stdin/stdout支持交互操作，这时候bash命令不会自动退出。
    {% endnote %}

- docker ps [OPTIONS]
    - 示例：
        - docker ps -l -q
    - -a: 列出当前所有正在运行的容器+历史上运行过的
    - -l: 显示最近创建的容器
    - -n: 显示最近n个创建的容器
    - -q: 静默模式，只显示容器编号

- docker commit
    - 示例: 
        - docker commit -m "A new custom image" -a "zchaoyu" 477973e96f4b zchaoyu1126/apache2:webserver
    - -m: 指定提交信息
    - -a: 镜像的作者信息

    {% note info simple %}
    仅提交创建容器的镜像与容器当前状态之间的差异部分
    {% endnote %}

- docker build
- docker images




```docker
docker build -t="zchaoyu1126/static_web" .
```

.告诉Docker从本地目录中寻找Dockerfile文件

或者也可以

```docker
docker build -t="zchaoyu1126/static_web:v1" git@github.com:zchaoyu1126/docker-static_web
```

这里假设这个git仓库的根目录下存在dockerfile文件

自从docker1.5开始，可以通过-f标志指定一个区别于Dockerfile的构建源的位置

```docker
docker build -t="sd s" -f path/to/file
```

这个文件可以不必命名为Dockerfile，但必须位于构建上下文之中

```docker
docker build --no-cache -t="sad"
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b1bbc0e-8a03-47a2-8468-58c2bffedcc9/Untitled.png)

docker images 查看已有镜像

docker history sdsafsahsa 查看历史

```docker
docker run -d -p 80 --name static_web zchaoyu1126/static_web nginx -g "daemon off;"
```

-d 选项，以分离（detached）的方式在后台运行

指定需要在容器中运行的命令 nginx -g “daemon off;” 这将以前台运行的方式启动nginx，来作为web服务器

-p 随机选择一个位于32768~61000的比较大的端口号来映射到80

可以在Docker宿主机中指定一个具体的端口号来映射到容器中的80端口上

docker ps -l 可查看端口分配情况

docker ps <container-id/container-name> 80 查看container-id 80对应的端口号

```docker
docer .... -p 8080:80
docker ... -p 127.0.0.1:80:80
docker ... -p 127.0.0.1::80  随机端口
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3d19f68c-0c1c-4f41-8b52-3c97d2b9626e/Untitled.png)


提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。

Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。

一些初学者将 CMD 写为：

CMD service nginx start
然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。

而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ "sh", "-c", "service nginx start"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。

正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：

CMD ["nginx", "-g", "daemon off;"]