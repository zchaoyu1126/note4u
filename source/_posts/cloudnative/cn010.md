---
title: 《K8S in Action》第四章笔记
categories: Cloud Native
cover: 'http://img.note4u.top/base/cnnotes_cover.jpg'
abbrlink: 90f3ebae
date: 2023-04-19 21:20:27
tags:
hide: true
---

## pod 探针

使用K8S的一个好处是，可以给K8S一个容器列表来由其保持容器在集群中的运行。
可以通过让K8S创建pod资源，为其选择一个工作节点，并在该节点上运行该pod的容器来完成此操作。

如果其中一个容器终止？一个pod中的所有容器都终止？怎么办？

只要将pod调度到某个节点，该节点的kubelet就会运行pod的容器，从此只要该pod在，就会保持运行。

如果容器的主进程崩溃，Kubelet将会重启容器。
如果应用程序中有一个导致它每个一段时间就会崩溃的bug，k8会自动重启。
即使应用程序本身没有做任何特殊的事情，在k8s中运行也能获得自我修复的能力。

即使进程没有崩溃，有时应用程序也会停止正常工作。例如，具有内存泄漏的Java应用程序将开始抛出 OutOfMemoryErrors，但JVM进程会一直运行。

让应用程序向 K8S发出信号，告诉它运行异常，让其重启。--》一个崩溃的容器会自动重启，所以捕获错误，并在错误发生时推出进程。但这并不能解决所有问题。

K8S 可以通过存活探针（liveness probe）检查容器是否还在运行。
可以为pod中的每个容器单独指定存活探针。如果探测失败，K8S 将定期执行探针并重新启动容器。

- HTTP GET探针对容器的IP地址（你指定的端口和路径）执行HTTP GET请求。
- TCP 套接字探针尝试与容器指定端口建立 TCP 连接。
- Exec 探针在容器内执行任意命令，并检查命令的退出状态码。 如果状态码是0，则探测成功。

### 基于 HTTP GET 请求的存活探针

``` SHELL
kubectl create -f kubia-liveness.yaml
```

``` YAML
apiVersion: v1
kind: Pod
metadata:
  name: kubia-liveness-pod
spec:
  containers:
  - name: kubia-liveness-container
    image: luksa/kubia-unhealthy
    resources:
      limits:
        memory: "128Mi"
        cpu: "500m"
    ports:
      - containerPort: 8080
        protocol: TCP
    livenessProbe:
      httpGet:
        path: /
        port: 8080
```

![20230420170617](http://img.note4u.top/article/20230420170617.png)


kubectl logs kubia-liveness-pod --previous
Kubia server starting...
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1

kubectl logs kubia-liveness-pod
Kubia server starting...
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
Received request from ::ffff:10.244.0.1
## ReplicationController

## ReplicaSet

## DaemonSet

## Job、CronJob